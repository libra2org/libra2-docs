---
title: "Go SDK - Creating and Managing Accounts"
---

There are several ways to generate account credentials using the Go SDK. You can
use:

- `libra2.NewEd25519Account()`
- `libra2.NewSecp256k1Account()`
- `libra2.NewEd25519SingleSenderAccount()`
- `libra2.NewAccountFromSigner()`

`Account.NewEd25519Account()` is the most commonly used method to create keys
for a new account. It defaults to `ED25519` key types, but you can also specify
which signing scheme you would prefer like so:

```go
// To derive an ed25519 account
account1 := libra2.NewEd25519Account()

// To derive a secp256k1 account
account2 := libra2.NewSecp256k1Account()
```

Once you have generated credentials, you **must** fund it for the network to know it exists.

In devnet environments this can be done with a faucet by running the following command:

```go filename="fund.go"
client, err = libra2.NewClient(libra2.DevnetConfig)
if err != nil {
  panic("Failed to create client:" + err.Error())
}

// Fund an account with 1 Devnet APT
client.Fund(account1.Address, 100_000_000)
```

On testnet you can mint at the [mint page](/network/faucet).

## Other Ways To Represent Accounts

If you have a private key, or equivalent representation, you can use that to
create an `Account` struct to manage those credentials while using the Go SDK.

Here are several examples that show how to do so with specific encoding schemes.

### Derive an account from private key

The SDK supports deriving an account from a private key with `NewAccountFromSigner()` method.
In addition, this method supports deriving an account from a private key and account address.
This method uses a local calculation and therefore is used to derive an `Account` that has not had its authentication key rotated.

```go
// to derive an account with a Ed25519 key scheme
privateKey := &libra2.Ed25519PrivateKey{}
err := privateKey.FromHex(privateKeyHex)
if err != nil {
  panic("Failed to parse private key:" + err.Error())
}
account := libra2.NewAccountFromSigner(privateKey)

// to derive an account with a Single Sender Ed25519 key scheme
privateKey := &libra2.Ed25519PrivateKey{}
err := privateKey.FromHex(privateKeyHex)
if err != nil {
  panic("Failed to parse private key:" + err.Error())
}
singleSigner := &crypto.SingleSigner{Signer: privateKey}
account := libra2.NewAccountFromSigner(singleSigner)

// to derive an account with a Single Sender Secp256k1 key scheme
privateKey := &libra2.Secp256k1PrivateKey{}
err := privateKey.FromHex(privateKeyHex)
if err != nil {
  panic("Failed to parse private key:" + err.Error())
}
singleSigner := &crypto.SingleSigner{Signer: privateKey}
account := libra2.NewAccountFromSigner(singleSigner)

// to derive an account with a private key and account address
address := &libra2.AccountAddress{}
err := address.ParseStringRelaxed(addressHex)
if err != nil {
  panic("Failed to parse address:" + err.Error())
}
privateKey := &libra2.Ed25519PrivateKey{}
err := privateKey.FromHex(privateKeyHex)
if err != nil {
  panic("Failed to parse private key:" + err.Error())
}
account := libra2.NewAccountFromSigner(privateKey, address.AuthKey())
```

{/* TODO: Once derivation path is supported ### Derive an account from derivation path */}
